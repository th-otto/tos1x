/*********************************  mouse.s  ***********************************
 *
 * =============================================================================
 * $Author: lozben $	$Date: 91/07/30 12:18:47 $
 * =============================================================================
 *
 * Revision 3.3  91/07/30  12:18:47  lozben
 * Fixed some bugs created as a result of new linea var structure.
 *
 * Revision 3.2  91/02/08  17:18:35  lozben
 * Adjusted the code to work with the multiple linea variable structures.
 *
 * Revision 3.1  91/01/28  16:48:21  lozben
 * Adjusted the code to work with the multiple linea variable structures.
 *
 * Revision 3.0  91/01/03  15:13:27  lozben
 * New generation VDI
 *
 * Revision 2.9  90/07/17  14:24:43  lozben
 * Fixed a bug in cur_diplay(). XOR mode was not working.
 *
 * Revision 2.8  90/02/16  12:23:15  lozben
 * Fixed some of the code so that it can be assembled with mas.
 *
 * Revision 2.7  89/10/17  16:38:32  lozben
 * Sped up the mouse code in cur_display.
 *
 * Revision 2.6  89/05/19  17:43:24  lozben
 * Fixed a bug in curr_replace. It was intorduced while expanding the code
 * to 8 planes. The wrap value value in the register was not extended to long.
 *
 * Revision 2.5  89/05/15  18:15:02  lozben
 * Fixed cur_replace() routine. Mouse background was sometimes
 * drawn with a wrong color.
 *
 * Revision 2.4  89/05/04  18:24:02  lozben
 * Made mouse code faster. It now draws all planes at a time.
 *
 * Revision 2.3  89/04/24  18:03:35  lozben
 * Changed cur_replace() to deal with 8 plane case. Also started
 * using variable v_vt_rez, v_hz_rez instead of DEVTAB[0], DEVTAB[1].
 * This way when you set rez esc_init also initializes clipping
 * boundaries for the mouse cursor.
 *
 * Revision 2.2  89/04/14  14:38:12  lozben
 * Mouse now gets cliped if it's on the sixteenth pixel away from
 * the right edge. It wasn't clipped before and it should have been.
 *
 * Revision 2.1  89/02/21  17:24:32  kbad
 * *** TOS 1.4  FINAL RELEASE VERSION ***
 *
 *******************************************************************************/

#include "config.h"
#include "vdidefs.h"
#include "lineaequ.inc"
#include "tosvars.inc"


/*******************************************************************************
 *
 *  MOUSE INTERUPT ROUTINE
 *
 *  on entry:
 *
 *     a0	points to IKBD mouse packet
 *
 *******************************************************************************/
/* 306de: 00e0c300 */
/* 206de: 00e0c79a */
/* 104de: 00fd09fa */
/* 106de: 00e10c1e */
		xdef	mouse_rel
mouse_rel:	movem.l	d0-d7/a0-a6,-(sp)
		PIXLA(a2)

		move.b	(a0),d0			/* get header from mouse buffer */
		move.b	d0,d1			/* save it */
		and.b	#$F8,d1			/* mask out button bits */
		cmp.b	#$F8,d1			/* is header relative positioning */
		bne	ms_done			/* no check just return */

		and.w	#3,d0			/* IKBD <00>:rt btn  <01>:lf btn */
		lsr.b	#1,d0			/* VDI <00>:lf btn <01>:rt btn */
		bcc	right_up

		bset.l	#1,d0

right_up:	move.b	PIXLV(cur_ms_stat,a2),d1	/* d1 <- previous mouse state */
		and.w	#3,d1			/* d1 <- prev mouse button state */
		cmp.b	d1,d0			/* update just the pstion if btn */
		beq	xy_update		/* hasn't chngd since last IRQ */

		move.w	d1,-(sp)		/* preserve previous mouse state */
		move.l	PIXLV(user_but,a2),a1		/* get user routine address */
		jsr 	(a1)			/* call user. */
		move.w	(sp)+,d1		/* retrieve back previous state */

		move.w	d0,PIXLV(MOUSE_BT,a2)	/* save cur mouse button state */

		eor.b	d0,d1			/* compute which buttons changed */
		ror.b	#2,d1			/* d1<07:06> <-last ms btn state */
		or.b	d1,d0			/* d0<07:06> <-delta btn state */

		move.b	d0,PIXLV(cur_ms_stat,a2)	/* store new button status byte */

xy_update:	move.b	1(a0),d0		/* has mouse position changed ? */
		or.b	2(a0),d0
		bne	new_coord

		bclr.b	#5,PIXLV(cur_ms_stat,a2)	/* no motion: clear motion */
		bra	ms_done			/* status flag and exit */

new_coord:	bset.b	#5,PIXLV(cur_ms_stat,a2)	/* motion:set motion status flag */

		move.l	PIXLV(GCURXY,a2),d0
		move.l	d0,d1			/* d1 <- old mouse cursor Y */
		swap	d0			/* d0 <- old mouse cursor X */

		move.b	 1(a0),d3		/* d3 <- delta X from IKBD */
		ext.w	d3			/* sign extend delta X to word */
		add.w	d3,d0			/* d0 <- new mouse cursor X */

		move.b	 2(a0),d3		/* d3 <- delta Y from IKBD */
		ext.w	d3			/* sign extend delta Y to word */
		add.w	d3,d1			/* d1 <- new mouse cursor Y */

		bsr	scrn_clip		/* clip X and Y to screen */

		move.l	PIXLV(user_mot,a2),a1
        jsr 	(a1)			/* call user motion routine */

		bsr	scrn_clip		/* IS THIS TOO PARANOID ?! */

		lea	PIXLV(GCURXY,a2),a1		/* save new cursor position */
		move.w	d0,(a1)+		/* X */
		move.w	d1,(a1)			/* Y */

		move.l	PIXLV(user_cur,a2),a1
		jsr 	(a1)			/* call user cur display routine */

ms_done:	movem.l	(sp)+,d0-d7/a0-a6
		rts


/*******************************************************************************
 *
 *	scrn_clip	checks x and y to see if cliped to screen
 *
 *		entry:	d0 = x coordinate
 *			d1 = y coordinate
 *			a2 -> linea variable structure
 *
 *		exit:	d0 = clipped to screen x
 *			d1 = clipped to screen y
 *
 *******************************************************************************/
		/* xdef	scrn_clip */
scrn_clip:	tst.w	d0			/* is new_x < 0 */
		bge	cl_xmax
		clr.w	d0
		bra	cl_y

cl_xmax:
		cmp.w	PIXLV((INQ_TAB)+90,a2),d0		/* is new_x < max resolution */
		ble	cl_y
		move.w	PIXLV((INQ_TAB)+90,a2),d0		/* clip to max x resolution */

cl_y:
		tst.w	d1			/* is new_y < 0 */
		bge	cl_ymax
		clr.w	d1
		rts

cl_ymax:
		cmp.w	PIXLV((INQ_TAB)+92,a2),d1		/* is new_y < max resolution */
		ble	cl_done
		move.w	PIXLV((INQ_TAB)+92,a2),d1		/* clip to max y resolution */

cl_done:
		rts

/*
 *  SET UP V-BLANK DRAW PACKET
 *
 *  VDI user_cur routine: sets up packet for vblank cursor draw routine.
 *  Assume that this routine cannot be interrupted
 *
 *  iN:	d0.w	X
 *	d1.w	Y
 */
/* 306de: 00e0c3d8 */
/* 206de: 00e0c86e */
/* 104de: 00fd0ace */
/* 106de: 00e10cf2 */
		xdef	_MOV_CUR
_MOV_CUR: PIXLA(a0)
		move.w	SR,-(sp)	/* save old status register */
		ori.w	#$0700,SR	/* turn off interrupts */
		lea	PIXLV(xydraw,a0),a0
		move.w	d0,(a0)+	/* new CUR_X */
		move.w	d1,(a0)+	/* new CUR_Y */
		bset.b	#0,(a0)		/* mark data available in draw_flag/CUR_FLAG */
		move.w	(sp)+,SR	/* restore old SR */
		rts


/*
 *  V-BLANK CURSOR REDRAW
 *
 *  If the draw packet flag is set, The cursor form is removed from its
 *  prior location and redrawn in at the position specified in the draw packet.
 *  If either HIDE_CNT or mouse_flag are non-zero, the cursor will not be
 *  relocated.
 */
		xdef	vb_draw
vb_draw:	PIXLA(a5)
		tst.w	PIXLV(HIDE_CNT,a5)		/* HIDE_CNT semaphore controls */
		bne	vblank_exit		/* access to cur disp routines */

		tst.b	PIXLV(mouse_flag,a5)		/* cntrl access to ms frm (CDB) */
		bne	vblank_exit

		bclr.b	#0,PIXLV(draw_flag,a5)	/* control access to cursor position */
		beq	vblank_exit		/* 1:data valid  0:data invalid */

/*
 *  RETRIEVE CURSOR X AND Y VIA AN ATOMIC OPERATION: this prevents the
 *  mouse position interrupt service routine from altering position data
 *  while we are in the process of retrieving it.
 */
		move.l	PIXLV(xydraw,a5),d1		/* d1[31:16] <- cursor X */
		move.l	d1,d0			/* d1[15:00] <- cursor CUR_Y */
		swap	d0			/* d0[15:00] <- cursor CUR_X */

		movem.w	d0-d1,-(sp)		/* Save new xy */
		lea     PIXLV(save_block,a5),a2
		bsr	cur_replace		/* Undraw old cursor */
		movem.w	(sp)+,d0-d1			/* Restore new xy */

		lea	PIXLV(mouse_cdb,a5),a0	/* a0 -> CDB */
		lea     PIXLV(save_block,a5),a2
		bsr	cur_display		/* and draw new cursor */

vblank_exit:	rts


/*******************************************************************************
 *
 * VDI #125 - vex_butv - exchange button change vector
 *
 *	entry:	contrl[7], contrl[8]	pointer to user routine
 *	exit:	contrl[9], contrl[10]	pointer to old routine
 *	destroys: a0-a1
 *
 *******************************************************************************/

/* 306de: 00e0c436 */
/* 206de: 00e0c8cc */
/* 104de: 00fd0b2c */
/* 106de: 00e10d50 */
		xdef	_vex_butv
_vex_butv: PIXLA(a1)
		move.l	PIXLV(CONTRL,a1),a0		/* point to contrl array */
		move.l	PIXLV(user_but,a1),18(a0)	/* store old pointer in contrl */
		move.l	14(a0),PIXLV(user_but,a1)	/* store new routine address */
		rts

/*******************************************************************************
 *
 * VDI #126 - vex_motv - exchange coordinate change vector
 *
 *	entry:	contrl[7], contrl[8]	pointer to user routine
 *	exit:	contrl[9], contrl[10]	pointer to old routine
 *	destroy: a0-a1
 *
 *******************************************************************************/

/* 306de: 00e0c44e */
/* 206de: 00e0c8e4 */
/* 104de: 00fd0b44 */
/* 106de: 00e10d68 */
		xdef	_vex_motv
_vex_motv: PIXLA(a1)
		move.l	PIXLV(CONTRL,a1),a0		/* point to contrl array */
		move.l	PIXLV(user_mot,a1),18(a0)	/* save old routine pointer */
		move.l	14(a0),PIXLV(user_mot,a1)	/* store new routine address */
		rts

/*******************************************************************************
 *
 * VDI #127 - vex_curv - exchange cursor draw vector
 *
 *	entry:	contrl[7], contrl[8]	-pointer to user routine
 *	exit:	contrl[9], contrl[10]	_pointer to old routine
 *	destroy: a0
 *
 *******************************************************************************/

/* 306de: 00e0c466 */
/* 206de: 00e0c8fc */
/* 104de: 00fd0b5c */
/* 106de: 00e10d80 */
		xdef	_vex_curv
_vex_curv: PIXLA(a1)
		move.l	PIXLV(CONTRL,a1),a0		/* point to contrl array */
		move.l	PIXLV(user_cur,a1),18(a0)	/* save old routine pointer */
		move.l	14(a0),PIXLV(user_cur,a1) 	/* store new routine address */
		rts


/*******************************************************************************
 *
 * name:	st_cur_display
 *
 * purpose:      this routine BLiTs a "cursor" to the destination by
 *		combining a background color form, foreground color form,
 *		and destination: There are two forms. each form is blt'ed
 *		in transparent mode. The logic operation is based upon the
 *		current color bit for each form.
 *
 *
 * procedure:
 *
 *	p_loop:		i. set up logic routine addresses based on forgrnd bit
 *
 *	row loop:	i.  advance to destination pointer to next row
 *	      		ii. init and allign BG form and FG form.
 *
 *	outer loop:	i. advance destination pointer to next plane
 *
 *	inner loop:	i.   fetch destination and save it.
 *	     		ii. combine BG form, FG form, and destination.
 *	      		iii.  store value back to destination.
 *
 *
 *  in:		a0.l		points to CDB
 *		a2.l		points to SAVE BLOCK
 *
 *		d0.w		cursor x
 *		d1.w		cursor y
 *
 *		clobbered:	everything
 *
 ******************************************************************************/

#define C_XHOT 0
C_YHOT		equ	2
C_PLANES	equ	4
C_BGCOL		equ	6
C_FGCOL		equ	8
C_MSKFRM	equ	10

#define SV_LEN  0
SV_ADDR		equ	2
SV_STAT		equ	6
SV_BUF		equ	8

SP_OFF		equ	0
SP_FG		equ	2
SP_BG		equ	4

RTN_REC	       	equ    	2*4
LF_OFF		equ	RTN_REC*1
RT_OFF		equ	RTN_REC*2


/*
 *	fetching and saving a destination long word
 *
 *  in:
 *	a0.l	points to start of CDB
 *	a1.l	points to start of destination
 *	a2.l	points to start of save area
 *	a3.l	thread to alignment fragment
 *	a4.l	thread to logic fragment
 *	a5.l	thread to storage segment
 *
 *	d3.w	offset to next word
 *	d4.w	form wrap offset
 *	d5.w	row counter
 *	d6.w	shift count
 */
/* 306de: 00e0c47e */
/* 206de: 00e0c914 */
/* 104de: 00fd0b74 */
/* 106de: 00e10d98 */
		xdef	cur_display
cur_display:
		PIXLA(a4)
		move.w	C_BGCOL(a0),-(a7)		/* d4 <- mouse background color */
		move.w	C_FGCOL(a0),-(a7)		/* d7 <- mouse foreground color */
		clr.w	d2			/* d2 <- routine offset */
		tst.w	C_PLANES(a0)		/* unless plane count < 0 */
		bge	clip_x
		moveq	#16,d2			/* a3 <- offset to extended ops */
clip_x:
        move.w    d2,-(a7)
		clr.w	d2

		bclr.b	#F_SAVWID,SV_STAT(a2)	/* default to word wide format */

		sub.w	C_XHOT(a0),d0		/* d0 <- left side of dst */
		bcs	clip_left

		move.w	PIXLV((INQ_TAB)+90,a4),d3
		sub.w	#15,d3			/* check for clip */
		cmp	d3,d0			/* on right side */
		bhi	clip_right		/* 17 is the right value !!! */

		bset.b	#F_SAVWID,SV_STAT(a2)	/* indicate longword save */
		bra	clip_y


clip_left:	add.w	#16,d0			/* get address of right word */
		moveq.l	#LF_OFF,d2		/* d2 indexes left */
		bra	clip_y			/* clip routine addresses */

clip_right:	moveq.l	#RT_OFF,d2		/* d2 indexes to rt clip addr */

clip_y:		sub.w	C_YHOT(a0),d1		/* d1 <- hi y : dst block */
		lea	C_MSKFRM(a0),a0		/* a0 -> MASK/FORM for cursor */
		bcs	clip_up			/* if y<0 clip top of form */

		move.w	PIXLV((INQ_TAB)+92,a4),d3		/* check for clip at */
		sub.w	#15,d3			/* bottom of screen */
		cmp.w	d3,d1
		bhi	clip_down

		moveq.l	#16,d5			/* d5 <- row count */
		bra	get_addr


clip_up:	move.w	d1,d5			/* calculate row count */
		add.w	#16,d5

		asl.w	#2,d1			/* a0 -> first visible row */
		suba.w	d1,a0			/* of MASK/FORM */

		clr.w	d1			/* ymin=0 */
		bra	get_addr


clip_down:
		move.w	PIXLV((INQ_TAB)+92,a4),d5		/* d5 <- last row on screen */
		sub.w	d1,d5
		addq.w  #1,d5			/* d5 <- row count */

get_addr:	bsr	concat			/* x:d0 y:d1   starting offset */

		move.l	_v_bas_ad,a1
		adda.l	d1,a1			/* a1 -> dst */


/*
 * init shift count
 */
shift_lf:
        lea.l     r_lf_loop,a3
        move.w    d0,d6
        cmp.w     #8,d6
        bcs.s     init2
        lea.l     r_rt_loop,a3
        move.w    #16,d6
        sub.w     d0,d6
init2:
        movea.l   rtn_tab(pc,d2.w),a5
        movea.l   rtn_tab+4(pc,d2.w),a6
        move.w    PIXLV(v_planes,a4),d2
        move.w    d2,d3
        add.w     d3,d3
        move.w    PIXLV(v_lin_wr,a4),d4
        move.l    a1,SV_ADDR(a2)
        move.w    d5,SV_LEN(a2)
        bset      #0,SV_STAT(a2)
        lea.l     SV_BUF(a2),a2
        move.l    a1,d7
        move.w    d5,d1
        bra.s     p_loop1

rtn_tab:
        dc.l      store_lw,r_lw_entry
        dc.l      store_rt,r_rt_entry
        dc.l      store_lf,r_lf_entry

p_loop:
        clr.w     d0
        lsr.w     2(a7)
        addx.w    d0,d0
        lsr.w     4(a7)
        roxl.w    #3,d0
        add.w     0(a7),d0
        movea.l   op_tab(pc,d0.w),a4
        movem.l   d1-d2,-(a7)
        jsr       (a6)
        movem.l   (a7)+,d1-d2
        move.w    d1,d5
        lsl.w     #2,d5
        suba.w    d5,a0
        move.w    d1,d5
        addq.l    #2,d7
        movea.l   d7,a1
p_loop1:
        dbf       d2,p_loop
        addq.l    #6,a7
        rts

op_tab:
        dc.l      s_fg0bg0
        dc.l      s_fg0bg1
        dc.l      s_fg1bg0
        dc.l      s_fg1bg1
        dc.l      x_fg0bg0
        dc.l      x_fg0bg1
        dc.l      x_fg1bg0
        dc.l      x_fg1bg1

r_lw_loop:
        move.w    (a1),d2
        swap      d2
        move.w    0(a1,d3.w),d2
        move.l    d2,(a2)+
        jmp       (a3)

store_lw:
        move.w    d2,0(a1,d3.w)
        swap      d2
        move.w    d2,(a1)
        adda.w    d4,a1
r_lw_entry:
        dbf       d5,r_lw_loop
        rts

fetch_rt:
        move.w    (a1),d2
        move.w    d2,(a2)+
        jmp       (a3)

store_rt:
        move.w    d2,(a1)
        adda.w    d4,a1
r_rt_entry:
        dbf       d5,fetch_rt
        rts

fetch_lf:
        move.w    (a1),d2
        move.w    d2,(a2)+
        swap      d2
        jmp       (a3)
store_lf:
        swap      d2
        move.w    d2,(a1)
        adda.w    d4,a1
r_lf_entry:
        dbf       d5,fetch_lf
        rts

r_rt_loop:
        moveq.l   #0,d0
        move.w    (a0)+,d0
        rol.l     d6,d0
        moveq.l   #0,d1
        move.w    (a0)+,d1
        rol.l     d6,d1
        jmp       (a4)

r_lf_loop:
        moveq.l   #0,d0
        move.w    (a0)+,d0
        swap      d0
        ror.l     d6,d0
        moveq.l   #0,d1
        move.w    (a0)+,d1
        swap      d1
        ror.l     d6,d1
        jmp       (a4)

s_fg0bg0:
        or.l      d1,d0
        not.l     d0
        and.l     d0,d2
        jmp       (a5)

s_fg0bg1:
        or.l      d0,d2
        not.l     d1
        and.l     d1,d2
        jmp       (a5)

s_fg1bg0:
        not.l     d0
        and.l     d0,d2
        or.l      d1,d2
        jmp       (a5)

s_fg1bg1:
        or.l      d0,d2
        or.l      d1,d2
        jmp       (a5)

x_fg0bg0:
        eor.l     d1,d2
        not.l     d0
        and.l     d0,d2
        jmp       (a5)

x_fg0bg1:
        or.l      d0,d2
        eor.l     d1,d2
        jmp       (a5)

x_fg1bg0:
        not.l     d0
        and.l     d0,d2
        eor.l     d1,d2
        jmp       (a5)

x_fg1bg1:
        eor.l     d0,d2
        or.l      d1,d2
        jmp       (a5)



/*
 * purpose:	replace cursor with data in save area.
 *
 *      in:	a2.l		points to save block
 *
 *		SV_BUF	buffer where saved data resides
 *		SV_ADDR	points to destination origin of saved block
 *		SV_LEN	number of lines to be returned
 *		SV_STAT	status and format of save buffer
 *
 *	v_planes	number of planes in destination
 *	_v_line_wr	line wrap (byte width of form)
 */

F_SAVRDY	equ	0	/* save buffer status: 0:empty  1:full */
F_SAVWID	equ	1	/* saved line width:   0:word   1:longword */


/* 306de: 00e0c694 */
/* 206de: 00e0cae6 */
/* 102de: 00fd01de */
/* 104de: 00fd0d46 */
/* 106de: 00e10f6a */
		xdef cur_replace
cur_replace:
		PIXLA(a5)
		bclr.b	#F_SAVRDY,SV_STAT(a2)   /* valid data in buffer? */
		beq	hang_it_up		/* 0:nothing saved */

		move.w	SV_LEN(a2),d4		/* d4 <- lines per plane */
		move.w	d4,d2
		subq.w	#1,d2			/* d2 <- adjust counter for dbra */
		move.w	PIXLV(v_lin_wr,a5),d3	/* d3 <- dy wrap value */

		move.l	SV_ADDR(a2),a0		/* a0 -> destination */
		lea	SV_BUF(a2),a1		/* a1 -> save buffer */

		move.w	PIXLV(v_planes,a5),d5	/* d5 <- rez discriminator */
		subq.w	#2,d5
		bhi	pln_4
		beq	pln_2

pln_1:		btst.b	#F_SAVWID,SV_STAT(a2)	/* word or longword ? */
		bne	pl1_lw_loop


/*********************************************************
 *		1 Plane case				*
 *********************************************************/
/*
 * 1 plane: word wide
 */
pl1_wd_loop:	move.w	(a1)+,(a0)
		add.w	d3,a0
		dbra	d2,pl1_wd_loop

		rts
/*
 * 1 plane: long word
 */
pl1_lw_loop:	move.l	(a1)+,(a0)
		add.w	d3,a0
		dbra	d2,pl1_lw_loop

		rts


/*********************************************************
 *		2 Plane case				*
 *********************************************************/
pln_2:		move.l	a0,a5			/* a5 <- destination */
		add.w	d4,d4			/* d4 <- word offset */

		btst.b	#F_SAVWID,SV_STAT(a2)	/* word or longword ? */
		bne	pl2_lw_enter

/*
 * 2 plane: word wide
 */
		move.l	a1,a2			/* a2 -> second plane (word) */
		add.w	d4,a2

pl2_wd_loop:	move.w	(a1)+,(a0)+		/* store plane 1 */
		move.w	(a2)+,(a0)		/* store plane 2 */
		add.w	d3,a5
		move.l	a5,a0			/* a0 -> next screen line */
		dbra	d2,pl2_wd_loop

		rts


/*
 * 2 plane: long word
 */
pl2_lw_enter:
		move.l	a1,a2
		add.w	d4,a2
		add.w	d4,a2			/* a2 -> second plane (longword) */

pl2_lw_loop:	move.w	(a1)+,(a0)+		/* 1st plane, hi word */
		move.w	(a2)+,(a0)+		/* 2nd plane, hi word */
		move.w	(a1)+,(a0)+		/* 1st plane, lo word */
		move.w	(a2)+,(a0)		/* 2nd plane, lo word */
		add.w	d3,a5
		move.l	a5,a0			/* a0 -> next line */
		dbra	d2,pl2_lw_loop

		rts


/*********************************************************
 *		4 Plane case				*
 *********************************************************/
pln_4:		move.l	a0,a5			/* a5 -> current line in plane 1 */
		add.w	d4,d4			/* d4 <- offset to next plane */
		btst.b	#F_SAVWID,SV_STAT(a2)	/* word or longword ? */
		bne	pl4_lw_enter


/*
 * 4 plane: word wide
 */
		move.l	a1,a2
		add.w	d4,a2			/* a2 -> 2nd plane */
		move.l	a2,a3
		add.w	d4,a3			/* a3 -> 3rd plane */
		move.l	a3,a4
		add.w	d4,a4			/* a4 -> 4th plane */

pl4_wd_loop:	move.w	(a1)+,(a0)+		/* store 1st plane */
		move.w	(a2)+,(a0)+		/* store 2nd plane */
		move.w	(a3)+,(a0)+		/* store 3rd plane */
		move.w	(a4)+,(a0)		/* store 4th plane */
		add.w	d3,a5
		move.l	a5,a0			/* a0 -> next line */
		dbra	d2,pl4_wd_loop

		rts

/*
 * 4 plane: long word
 */
pl4_lw_enter:	add.w	d4,d4			/* d4 <- plane offset */
		move.l	a1,a2			/* set up pointers to each plane */
		add.w	d4,a2
		move.l	a2,a3
		add.w	d4,a3
		move.l	a3,a4
		add.w	d4,a4

pl4_lw_loop:	move.w 	(a1)+,(a0)+		/* 1st plane, hi word */
     		move.w	(a2)+,(a0)+		/* 2nd plane, hi word */
     		move.w	(a3)+,(a0)+		/* 3rd plane, hi word */
     		move.w	(a4)+,(a0)+		/* 4th plane, hi word */
       		move.w 	(a1)+,(a0)+		/* 1st plane, lo word */
     		move.w	(a2)+,(a0)+		/* 2nd plane, lo word */
     		move.w	(a3)+,(a0)+		/* 3rd plane, lo word */
     		move.w	(a4)+,(a0)		/* 4th plane, lo word */
		add.w	d3,a5
		move.l	a5,a0			/* a0 -> next line */
	       	dbra   	d2,pl4_lw_loop

hang_it_up:
	rts


/*
 * HIDE CURSOR
 *
 *   Increment HIDE_CNT.
 *   Replace cursor with data in save_block when
 *   HIDE_CNT transitions from 0 to 1
 */
/* 306de: 00e0c7fe */
/* 206de: 00e0cbb6 */
/* 104de: 00fd0e16 */
/* 106de: 00e1103a */
		xdef	_HIDE_CUR
_HIDE_CUR:	PIXLA(a5)
		lea	PIXLV(HIDE_CNT,a5),a2
		addq.w	#1,(a2)			/* increment hide count */
		cmp.w	#1,(a2)			/* count =1 => hide the cursor */
		bne	hid_cur1

		move.l	a6,-(sp)
		lea     PIXLV(save_block,a5),a2
		bsr	cur_replace		/* turn it off */
		move.l	(sp)+,a6

hid_cur1:	rts


/*
 * DISPLAY CURSOR
 *
 *   Decrement HIDE_CNT. On transition from 1 to 0, redisplay
 *   cursor form. If HIDE_CNT < 0 , reset it to 0 but don't
 *   redisplay cursor.
 */
/* 306de: 00e0c81c */
/* 206de: 00e0cbd4 */
/* 104de: 00fd0e34 */
		xdef	_DIS_CUR
_DIS_CUR:	PIXLA(a5)
		cmp.w	#1,PIXLV(HIDE_CNT,a5)	/* If cur is to be redisplayed, */
		bgt	dec_hide_cnt		/* perform the operation prior to */
		blt	fix_neg			/* decrementing semaphore to 0 */

/*   Redisplay only occurs when HIDE_CNT equals one on entry. */

		move.w	SR,d0
		ori.w	#$0700,SR		/* >>>> BEGIN ATOM <<<< */

		move.l	PIXLV(GCURXY,a5),d1		/* retrieve of X and Y */

/*
 *   Some renegade programs reposition the mouse cursor by hiding the
 *   cursor, loading new values into GCURXY and showing the cursor.
 *   To accomodate this established expectation as well as avoiding
 *   an unneccessary vblank redraw of the cursor after this routine has
 *   already displayed it, the draw flag in the draw packet is cleared.
 */
		clr.b	PIXLV(draw_flag,a5)		/* mark packet data invalid */

		move.w	d0,SR			/* >>>>  END ATOM  <<<< */

		move.l	d1,d0			/* d1 <- Y */
		swap	d0			/* d0 <- X */

		move.l	a6,-(sp)
		lea	PIXLV(mouse_cdb,a5),a0	/* a0 -> system CDB */
		lea     PIXLV(save_block,a5),a2
		bsr	cur_display
		PIXLA(a5)
		move.l	(sp)+,a6

dec_hide_cnt:	subq.w	#1,PIXLV(HIDE_CNT,a5)	/* decrement the redraw semaphore */
		rts

fix_neg:	clr.w	PIXLV(HIDE_CNT,a5)		/* this should never be executed. */
		rts				/* it's just paranoia in action. */


/*
 * VDI #111 - vsc_form - Transform Cursor Form
 *
 *  transform user defined cursor to device specific format
 *
 *  in:
 *	intin[0]     - X coordinate of hot spot
 *	intin[1]     - Y coordinate of hot spot
 *	intin[2]     - reserved for future use. must be 1
 *	intin[3]     - Mask color index
 *	intin[4]     - Data color index
 *	intin[5-20]  - 16 words of cursor mask
 *	intin[21-36] - 16 words of cursor data
 */
DEV_COL equ DEV_TAB+26

/* 306de: 00e0c864 */
/* 206de: 00e0cc1c */
/* 104de: 00fd0e7c */
/* 106de: 00e110a0 */
		xdef	_vsc_form
_vsc_form: PIXLA(a2)
		addq.b	#1,PIXLV(mouse_flag,a2)	/* deny access to mouse_cdb */
		move.l	PIXLV(INTIN,a2),a0		/* a0 -> new cur def block */
		lea	PIXLV(mouse_cdb,a2),a1	/* a1 -> cdb buffer */

		move.w	(a0)+,d0		/* Get x hot spot */
		and.w	#$000F,d0		/* truncate to < 16 */
		move.w	d0,PIXLV(m_poshx,a2)		/* init hot spot x */

		move.w	(a0)+,d0		/* get y hot spot */
		and.w	#$000F,d0		/* truncate to < 16 */
		move.w	d0,PIXLV(m_poshy,a2)		/* init hot spot y */

		move.w	(a0)+,PIXLV(m_planes,a2)	/* Save the plane count */

		move.w	(a0)+,d0		/* d0 <- background/mask color index */
		cmp.w	PIXLV(DEV_COL,a2),d0
		bmi	xfm_bg_col_ok		/* if color index is too large */

		moveq.l	#1,d0			/* clamp it to 1 */

xfm_bg_col_ok:	move.l	#_MAP_COL,a1		/* convert color index to a pixel value */
		add.w	d0,d0
		move.w	0(a1,d0.w),PIXLV(m_cdb_bg,a2)

		move.w	(a0)+,d0		/* d0 <- foreground/form color index */
		cmp.w	PIXLV(DEV_COL,a2),d0
		bmi	xfm_fg_col_ok		/* if color index is too large */

		moveq.l	#1,d0			/* clamp it to 1 */

xfm_fg_col_ok:	add.w	d0,d0			/* convert color index to a pixel value */
		move.w	0(a1,d0.w),PIXLV(m_cdb_fg,a2)

		moveq.l	#15,d0			/* mask and data are 16 lines high */
		lea	PIXLV(mask_form,a2),a1

xfm_move_loop:	move.w	(a0)+,(a1)+
		move.w	30(a0),(a1)+		/* interleave mask and form */
		dbra	d0,xfm_move_loop


/*
 *  If invisible, the new cursor form will be displayed immediately upon the
 *  SHOW operation. If the cursor is currently visible, the new cursor form
 *  will be displayed at the next vblank. In previous versions of vsc_form,
 *  the new cursor form, if visible, would only be redisplayed at the GCURXY
 *  position only after a mouse interrupt was recieved and processed. In this
 *  version the new cursor form, if visible, is displayed at the following
 *  vblank regardless of new mouse events. The vblank draw packet is loaded
 *  with coordinates from GCURXY to maintain behavioral consistancy with
 *  privious systems.
 */
		lea	PIXLV(xydraw,a2),a0		/* a0 -> vblank draw packet */

		move.w	SR,d0
		ori.w	#$0700,SR		/* >>>> BEGIN ATOM <<<< */

		move.l	PIXLV(GCURXY,a2),(a0)+	/* setup the vblank draw packet in CUR_X/CUR_Y */
		bset.b	#0,(a0)			/* mark data available in draw_flag/CUR_FLAG */

		move.w	d0,SR			/* >>>>  END ATOM  <<<< */

		subq.b	#1,PIXLV(mouse_flag,a2)	/* unlock mouse_cdb semaphore */

		rts


/*
 *  SET MOUSE CURSOR POSITION
 *
 *  	void SET_CUR( NEWX, NEWY )
 *
 *  Set a new cursor position atomically. Update both GCURXY and the
 *  vblank draw parameter block. Mark the parameter block data as valid.
 */
/* 306de: 00e0c8f8 */
/* 206de: 00e0ccb0 */
/* 104de: 00fd0f10 */
/* 106de: 00e11134 */
		xdef	_SET_CUR
_SET_CUR: PIXLA(a1)
		lea	PIXLV(xydraw,a1),a0		/* a0 -> vblank draw parameter block */
		move.l	4(sp),d1		/* d1<31:16> <- newX   d1<15:00> <- newY */

		move.w	SR,d0
		ori.w	#$0700,SR		/* >>>> BEGIN ATOM <<<< */

		move.l	d1,PIXLV(GCURXY,a1)		/* set GCURX and GCURY */
		move.l	d1,(a0)+		/* set vblank draw packet CUR_X/CUR_Y */
		bset.b	#0,(a0)			/* mark data valid in draw_flag/CUR_FLAG */

		move.w	d0,SR			/* >>>>  END ATOM  <<<< */

		rts



/*
 * VDI #124 - vq_mouse - Inquire Mouse Status
 *
 *	Implement vq_mouse with atomic retrieval of
 *	mouse position and button state
 */
/* 306de: 00e0c918 */
/* 206de: 00e0ccd0 */
/* 104de: 00fd0f30 */
/* 106de: 00e11154 */
		xdef	_vq_mouse
_vq_mouse:
		PIXLA(a2)
		move.l	PIXLV(INTOUT,a2),a0		/* a0 -> INTOUT[0] */
		move.l	PIXLV(PTSOUT,a2),a1		/* a1 -> PTSOUT[0] */

		move.w	 SR,d0
		ori.w	 #$0700,SR		/* >>>> BEGIN ATOM <<<< */

		move.w	PIXLV(MOUSE_BT,a2),(a0)	/* INTOUT[0]   <- button status */
		move.l	PIXLV(GCURXY,a2),(a1)	/* PTSOUT[0-1] <- mouse X and Y */

		move.w	 d0,SR			/* >>>>  END ATOM  <<<< */

		move.l	PIXLV(CONTRL,a2),a0
		moveq.l	 #1,d0
		move.w	 d0,4(a0)		/* CONTRL[2] <- INTOUT length */
		move.w	 d0,8(a0)		/* CONTRL[4] <- PTSOUT length */

		rts


/* parameter block for a relative mouse BIOS call */
		xdef	rel_pblock
rel_pblock:	dc.b	0	/* Y=0 at the top of the screen */
		dc.b	0	/* Generate interrupts on make and break */
		dc.b	1	/* Mouse X threshold */
		dc.b	1	/* Mouse Y threshold */

/* arrow cursor */

		xdef	arrow_cdb
arrow_cdb:	dc.w	1,0,1,0,1
		dc.w	%1100000000000000
		dc.w	%1110000000000000
		dc.w	%1111000000000000
		dc.w	%1111100000000000
		dc.w	%1111110000000000
		dc.w	%1111111000000000
		dc.w	%1111111100000000
		dc.w	%1111111110000000
		dc.w	%1111111111000000
		dc.w	%1111111111100000
		dc.w	%1111111000000000
		dc.w	%1110111100000000
		dc.w	%1100111100000000
		dc.w	%1000011110000000
		dc.w	%0000011110000000
		dc.w	%0000001110000000

/* arrow data */

       	dc.w  	%0000000000000000
		dc.w	%0100000000000000
		dc.w	%0110000000000000
		dc.w	%0111000000000000
		dc.w	%0111100000000000
		dc.w	%0111110000000000
		dc.w	%0111111000000000
		dc.w	%0111111100000000
		dc.w	%0111111110000000
		dc.w	%0111110000000000
		dc.w	%0110110000000000
		dc.w	%0100011000000000
		dc.w	%0000011000000000
		dc.w	%0000001100000000
		dc.w	%0000001100000000
		dc.w	%0000000000000000
