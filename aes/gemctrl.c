/*
 *************************************************************************
 *			Revision Control System
 * =======================================================================
 *  $Author: mui $	$Date: 89/04/26 18:21:33 $
 * =======================================================================
 *
 * Revision 2.3  89/04/26  18:21:33  mui
 * TT
 * 
 * Revision 2.2  89/04/06  17:58:24  kbad
 * changed hctl_window to use delay() system tick timer rather than evnt_ calls.
 * 
 * Revision 2.1  89/02/22  05:25:15  kbad
 * *** TOS 1.4  FINAL RELEASE VERSION ***
 * 
 * Revision 1.3  89/02/16  10:47:41  mui
 * Fix dclicks: take out gl_bpend stuf in ctrlmgr
 * 
 * Revision 1.2  89/02/14  08:51:45  kbad
 * fix at hctl_window to prevent double events being generated by single
 * clicks in window controls. 
 * 
 * Revision 1.1  88/06/02  12:31:14  lozben
 * Initial revision
 * 
 * Revision 1.1  87/11/20  14:14:07  lozben
 * Initial revision
 * 
 * =======================================================================
 *
 *************************************************************************
 */
/*	GEMCTRL.C	5/14/84 - 02/23/85	Lee Jay Lorenzen	*/
/*	pstart bugs,1.1	2/12/85 - 04/05/85	LKW			*/
/*	Reg Opt		03/09/85		Derek Mui		*/
/*	Fix at hctl_window 05/11/85 - 10/21/85	Derek Mui		*/
/*	Fix the button semaphore at ctlmgr	2/27/86	 Derek Mui	*/
/*	Ctlmouse to control the mouse 		03/05/86 Derek Mui	*/
/*	Change at ctlmouse to save mouse form by using line a function,	*/
/*	take out tmpmaddr	1/7/87		Derek Mui		*/
/*	Smooth scrolling	2/4/87		Derek Mui		*/
/*	Change at ctlmgr for smooth scrolling	3/11/87	Derek Mui	*/
/*	Fix at ctlmouse of gsx_ncode		12/11/87	D.Mui	*/
/*	Take out gl_fakemsg at hctl_button	2/17/88		D.Mui	*/
/*	Take out gl_fakemsg at hctl_button	6/25/90		D.Mui	*/
/*	Change the way it sends the arrow message 4/3/91	D.Mui	*/
/*	Change mn_do to mn_hdo			7/8/92		D.Mui	*/
/*	New codes to handle new window library	8/1/92		D.Mui	*/

/*
 *	-------------------------------------------------------------
 *	GEM Application Environment Services		  Version 1.1
 *	Serial No.  XXXX-0000-654321		  All Rights Reserved
 *	Copyright (C) 1985			Digital Research Inc.
 *	-------------------------------------------------------------
 */

#include "aes.h"
#include "gemlib.h"
#include "taddr.h"
#include "gsxdefs.h"


#if BINEXACT
extern int16_t gl_mnpid;
#endif

#define THEDESK 3

#define MBDOWN 0x0001
#define BELL 0x07						/* bell         */

LPTREE ml_mnhold;
GRECT ml_ctrl;
PD *ml_pmown;
PD *ml_pkown;
STATIC int16_t tmpmoff;
STATIC int16_t tmpmon;
MOBLK gl_ctwait;
int16_t appl_msg[8];
#if 0
int16_t rets[6];							/* added 2/4/87 ... and now unused */
#endif
int16_t ml_ocnt;



/* used to convert from window object # to window message code */
STATIC int16_t const gl_wa[] = {
	WA_UPLINE,
	WA_DNLINE,
	WA_UPPAGE,
	WA_DNPAGE,
	0x0,
	WA_LFLINE,
	WA_RTLINE,
	WA_LFPAGE,
	WA_RTPAGE
};


/*
 *	Send message and wait for the mouse button to come up
 */
/* 306de: 00e1b1b4 */
VOID ct_msgup(P(int16_t) message, P(int16_t) owner, P(int16_t) wh, P(int16_t) m1, P(int16_t) m2, P(int16_t) m3, P(int16_t) m4)
PP(int16_t message;)
PP(int16_t owner;)
PP(int16_t wh;)
PP(int16_t m1;)
PP(int16_t m2;)
PP(int16_t m3;)
PP(int16_t m4;)
{
	if (message)
		ap_sendmsg(appl_msg, message, owner, wh, m1, m2, m3, m4);
	/* wait for button to come up */
	while ((button & 0x0001) != 0x0)
		dsptch();
}


/* 104de: 00fddcc4 */
/* 206de: 00e1778e */
/* 306de: 00e1b1f4 */
VOID hctl_window(P(int16_t) w_handle, P(int16_t) mx, P(int16_t) my)
PP(register int16_t w_handle;)
PP(int16_t mx;)
PP(int16_t my;)
{
	register WINDOW *pwin;
	GRECT t, f;
	int16_t x, y, w, h;
	int16_t kind;
	int16_t px, py;
	OBJECT *tree;
	int16_t pw, ph;
	register int wm, hm;
	register int16_t message;
	register int16_t cpt;
	int16_t selst, nrmst, dummy;
	int16_t unused[3];
	PD *p;
	
	UNUSED(unused);
	UNUSED(dummy);
	UNUSED(nrmst);
	UNUSED(selst);
	UNUSED(pw);
	UNUSED(ph);
	
	pwin = srchwp(w_handle);
	message = 0;
	if (w_handle == gl_wtop /* ||
		((D.w_win[w_handle].w_flags & VF_SUBWIN) && (D.w_win[gl_wtop].w_flags & VF_SUBWIN)) */ )
	{
		/* 
		 * went down on active window so handle control points
		 */
		w_bldactive(w_handle);
		tree = gl_awind;
		UNUSED(tree);
#if BINEXACT
		cpt = ob_find((LPTREE) gl_awind, 10L, mx, my); /* sigh */
#else
		cpt = ob_find((LPTREE) gl_awind, 0, 10, mx, my);
#endif
        w_getsize(WS_CURR, w_handle, &t);
        r_get(&t, &x, &y, &w, &h);
		kind = pwin->w_kind;
		switch (cpt)
		{
		case W_CLOSER:
#if 0
			/*
			 * MagiC feature not supported by TOS;
			 * HOTCLOSE (0x1000) was later used for menubars (MENUBAR) in windows
			 */
			if (kind & HOTCLOSE)
			{
				message = WM_CLOSED;
				break;
			}
#endif
			/* else fall thru */
		case W_FULLER:
			if (gr_watchbox(gl_awind, cpt, SELECTED, NORMAL))
			{
				message = (cpt == W_CLOSER) ? WM_CLOSED : WM_FULLED;
				ob_change((LPTREE) gl_awind, cpt, NORMAL, TRUE);
			}
			break;
		case W_NAME:
			if (pwin->w_kind & MOVER)
			{
				/* prevent the mover gadget being moved completely offscreen */
				r_set(&f, 0, gl_hbox, gl_rscreen.g_w + w - gl_wbox - 6, 10000);
				gr_dragbox(w, h, x, y, &f, &x, &y);
				message = WM_MOVED;
			}
			break;
		case W_SIZER:
			if (kind & SIZER)
			{
				w_getsize(WS_WORK, w_handle, &t);
				t.g_x -= x;
				t.g_y -= y;
				t.g_w -= w;
				t.g_h -= h;
				wm = gl_wchar;
				hm = gl_hchar;
				if (pwin->w_kind & (LFARROW | RTARROW | HSLIDE))
					wm = gl_wbox * 7;
				if (pwin->w_kind & (UPARROW | DNARROW | VSLIDE))
					hm = gl_hbox * 7;
				gr_rubwind(x, y, wm, hm, &t, &w, &h);
				message = WM_SIZED;
			}
			break;
		case W_HSLIDE:
		case W_VSLIDE:
			/*
			 * cpt + 1: W_HSLIDE -> W_HELEV, W_VSLIDE -> W_VELEV
			 */
			ob_offset((LPTREE) gl_awind, cpt + 1, &px, &py);
			if (cpt == W_HSLIDE)
			{
				/* fix up for index into gl_wa */
				if (!(mx < px))
					cpt += 1;
			} else
			{
				if (!(my < py))
					cpt += 1;
			}
			/* fall thru */
		case W_UPARROW:
		case W_DNARROW:
		case W_LFARROW:
		case W_RTARROW:
			message = WM_ARROWED;
			break;
		case W_HELEV:
		case W_VELEV:
			message = cpt == W_HELEV ? WM_HSLID : WM_VSLID;
			/* slide is 1 less than elev */
			x = gr_slidebox((LPTREE) gl_awind, cpt - 1, cpt, cpt == W_VELEV);
			break;
		}
		if (message == WM_ARROWED)
		{
			x = gl_wa[cpt - W_UPARROW];
			wm_update(END_UPDATE);			/* give up the screen */

			cpt = TRUE;
			p = pwin->w_owner;
			do
			{
				if (p->p_stat == PS_MWAIT)
				{
					ap_sendmsg(appl_msg, message, pwin->w_owner->p_pid, w_handle, x, y, w, h);
				} else
				{
				}

				dsptch();

				/*
				 * Delay for half current double click time: 
				 * allow button to come back up on single click
				 */
				if (cpt)
				{						/* Only delay 1st time through */
					cpt = FALSE;
					delay((int32_t) gl_dclick);
				}

			} while (button & 1);		/* button is global */

			wm_update(BEG_UPDATE);			/* take back the screen */
			return;
		}
	} else
	{
        /*
         * went down on inactive window so tell ap. to bring it to top
         */
		message = WM_TOPPED;
#if 0 & SINGLAPP
		ct_msgup(WM_UNTOPPED, D.w_win[gl_wtop].w_owner->p_pid, gl_wtop, x, y, w, h);
	    for (i = 0; i < NUM_ACCS; i++)
    	    dsptch();
#endif
	}
	/* BUG: x, y, w, h undefined if w_handle != gl_wtop */
	ct_msgup(message, pwin->w_owner->p_pid, w_handle, x, y, w, h);
}


/* 306de: 00e1b580 */
VOID hctl_button(P(int16_t) mx, P(int16_t) my)
PP(register int16_t mx;)
PP(register int16_t my;)
{
	register int16_t wh;

	/* find out which wind. the mouse clicked over and handle it */

	if ((wh = wm_find(mx, my)) > 0)
		hctl_window(wh, mx, my);
}


/* 306de: 00e1b5b6 */
VOID hctl_rect(P(int16_t) mx, P(int16_t) my)
PP(int16_t mx;)
PP(int16_t my;)
{
	int16_t title, item;
	register int16_t owner, mesag;

	if (gl_mntree != 0 && inside(mx, my, &gl_rmnactv))
	{
		mesag = 0;
#if !BINEXACT
		owner = 0;
#endif
		if (mn_do(&title, &item))
		{
			/* check system menu: title == 1st menu && item == deskacc */
			if (gl_dacnt && title == THEDESK && item >= gl_dabase)
			{
				item -= gl_dabase;
				owner = desk_pid[item];
				do_chg(gl_mntree, title, SELECTED, FALSE, TRUE, TRUE);
				mesag = AC_OPEN;
			} else
			{
				owner = gl_mnpid;
				mesag = MN_SELECTED;
			}
		}
		/* application menu item has been selected so send it */
#if BINEXACT
		ct_msgup(mesag, owner, title, item, NULL, 0);
#else
		ct_msgup(mesag, owner, title, item, 0, 0, 0);
#endif
	}
}


/*
 *	Control change of ownership to this rectangle and this process
 *	Doing the control rectangle first is important.
 */
/* 306de: 00e1b67a */
VOID ct_chgown(P(PD *) ppd, P(GRECT *) pr)
PP(PD *ppd;)
PP(GRECT *pr;)
{
	/* set_ctrl(pr), copy the rect into control */
	rc_copy(pr, &ctrl);
	/* set_mkown(ppd, ppd);     */

	/* change the owner */
	gl_cowner = gl_mowner = ppd;
	/* pretend mouse moved to get the right form showing */
	/* and get mouse event posted correctly */
	post_mouse(gl_mowner, xrat, yrat);
	/* post a button event in case the new owner was waiting */
	post_button(gl_mowner, button, 1);

	gl_kowner = ppd;
}


/*
 *	Internal process context used to control the screen for use by
 *	the menu manager, and the window manager.
 *	This process never terminates and forms an integral part of
 *	the system.
 */
/* 306de: 00e1b6de */
VOID ctlmgr(NOTHING)
{
	register int16_t ev_which;
	int16_t lrets[6];

	/* set defaults for multi wait */
	rc_copy(&gl_rmenu, (GRECT *)&gl_ctwait.m_x);
	gl_ctwait.m_out = FALSE;			/* CHANGED LKW      */


	while (1)
	{
		w_setactive();
		/*
		 * if no waiting to go out of menu area
		 * then give mouse to owner of top window
		 */
		/* gsx_mxmy(&mx, &my); */
		/* gl_ctwait.m_out = inside(mx, my, &gl_ctwait.m_x); */

		/* wait for something to happen */
		ev_which = ev_multi(MU_KEYBD | MU_BUTTON | MU_M1, &gl_ctwait, &gl_ctwait, 0x0L, 0x0001ff01L, NULL, lrets);
		/* grab screen sink */
		wm_update(BEG_UPDATE);
		/* button down over area ctrl mgr owns  */
		if (ev_which & MU_BUTTON)
		{
			hctl_button(lrets[0], lrets[1]);
		}
		/* mouse over menu bar */
		if (ev_which & MU_M1)
		{
			hctl_rect(lrets[0], lrets[1]);
		}

		/* give up screen sink */
		wm_update(END_UPDATE);
	}
}


/*
 *	Create a process for the Screen Control Manager and start him 
 *	executing. Also do all the initialization that is required.  
 *	Also zero out the desk accessory count.
 */
/* 306de: 00e1b770 */
PD *ictlmgr(P(int16_t) pid)
PP(int16_t pid;)
{
	PD *px;
	register int32_t ldaddr;

	UNUSED(px);
	gl_dacnt = 0;
	gl_dabase = 0;
	/* figure out load addr */
	ldaddr = LLCS() + ((int32_t) & ctlmgr);
	/* create process to execute it */
	return pstart(&ctlmgr, "SCRENMGR.LOC", ldaddr);
}


/*
 * New routine to force arrow mouse and show mouse when it is over
 * the menu bar or there is an alert box	3/05/86
 */
/* 306de: 00e1b7aa */
VOID ctlmouse(P(BOOLEAN) mon)
PP(BOOLEAN mon;)
{
	if (mon)							/* turn on and show the mouse   */
	{
		getmouse();
		tmpmon = gl_mouse;				/* mouse on flag        */
		tmpmoff = gl_moff;
#if AESVERSION >= 0x320
		gsx_xmfset(ad_armice);			/* change the mouse form    */
#else
		gsx_mfset(ad_armice);			/* change the mouse form    */
#endif
		if (!gl_mouse)					/* if currently the mouse is    */
		{
			gsx_1acode(SHOW_CUR, 0);	/* off, then turn it on     */
			gl_mouse = TRUE;			/* set the flag         */
		}
		gl_moff = 0;					/* reset the flag to make bbset */
	} else
	{
#if BINEXACT /* sigh */
		gsx_ncode(HIDE_CUR, 0L);		/* turn off the mouse anyway    */
#else
		gsx_ncode(HIDE_CUR, 0, 0);		/* turn off the mouse anyway    */
#endif
		putmouse();						/* put the mouse back to the    */
		gl_mouse = FALSE;				/* way it was           */

		if (tmpmon)						/* the mouse was on     */
		{
#if BINEXACT
			gsx_ncode(SHOW_CUR, 0L); /* sigh */
#else
			gsx_ncode(SHOW_CUR, 0, 0);
#endif
			gl_mouse = TRUE;
		}

		gl_moff = tmpmoff;
	}
}



/*	0 = end mouse control	*/
/*	1 = mouse control	*/

/* 3066de: 00e1b846 */
VOID take_ownership(P(BOOLEAN) beg_ownit)
PP(BOOLEAN beg_ownit;)
{
	if (beg_ownit)
	{
		wm_update(BEG_UPDATE);
		if (ml_ocnt == 0)
		{
			ml_mnhold = gl_mntree;		/* save the current menu   */
			gl_mntree = 0;				/* no menu         */
			rc_copy(&ctrl, &ml_ctrl);	/* get_ctrl(&ml_ctrl);     */
			/* save the control rect */
			/* get_mkown(&ml_pmown, &ml_pkown); */

			ml_pmown = gl_mowner;		/* save the mouse owner    */
			ml_pkown = gl_kowner;		/* save the keyboard owner */

			ct_chgown(rlr, &gl_rscreen);	/* change mouse ownership  */
		}								/* and the control rect    */
		ml_ocnt++;
	} else
	{
		ml_ocnt--;
		if (ml_ocnt == 0)
		{
			ct_chgown(ml_pkown, &ml_ctrl);	/* restore mouse owner     */ /* BUG: ml_pkown is keyboard owner, not mouse */
			gl_mntree = ml_mnhold;		/* restore menu tree       */
		}
		wm_update(END_UPDATE);
	}
}
