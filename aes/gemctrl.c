/*
 *************************************************************************
 *			Revision Control System
 * =======================================================================
 *  $Author: mui $	$Date: 89/04/26 18:21:33 $
 * =======================================================================
 *
 * Revision 2.3  89/04/26  18:21:33  mui
 * TT
 * 
 * Revision 2.2  89/04/06  17:58:24  kbad
 * changed hctl_window to use delay() system tick timer rather than evnt_ calls.
 * 
 * Revision 2.1  89/02/22  05:25:15  kbad
 * *** TOS 1.4  FINAL RELEASE VERSION ***
 * 
 * Revision 1.3  89/02/16  10:47:41  mui
 * Fix dclicks: take out gl_bpend stuf in ctrlmgr
 * 
 * Revision 1.2  89/02/14  08:51:45  kbad
 * fix at hctl_window to prevent double events being generated by single
 * clicks in window controls. 
 * 
 * Revision 1.1  88/06/02  12:31:14  lozben
 * Initial revision
 * 
 * Revision 1.1  87/11/20  14:14:07  lozben
 * Initial revision
 * 
 * =======================================================================
 *
 *************************************************************************
 */
/*	GEMCTRL.C	5/14/84 - 02/23/85	Lee Jay Lorenzen	*/
/*	pstart bugs,1.1	2/12/85 - 04/05/85	LKW			*/
/*	Reg Opt		03/09/85		Derek Mui		*/
/*	Fix at hctl_window 05/11/85 - 10/21/85	Derek Mui		*/
/*	Fix the button semaphore at ctlmgr	2/27/86	 Derek Mui	*/
/*	Ctlmouse to control the mouse 		03/05/86 Derek Mui	*/
/*	Change at ctlmouse to save mouse form by using line a function,	*/
/*	take out tmpmaddr	1/7/87		Derek Mui		*/
/*	Smooth scrolling	2/4/87		Derek Mui		*/
/*	Change at ctlmgr for smooth scrolling	3/11/87	Derek Mui	*/
/*	Fix at ctlmouse of gsx_ncode		12/11/87	D.Mui	*/
/*	Take out gl_fakemsg at hctl_button	2/17/88		D.Mui	*/
/*	Take out gl_fakemsg at hctl_button	6/25/90		D.Mui	*/
/*	Change the way it sends the arrow message 4/3/91	D.Mui	*/
/*	Change mn_do to mn_hdo			7/8/92		D.Mui	*/
/*	New codes to handle new window library	8/1/92		D.Mui	*/

/*
 *	-------------------------------------------------------------
 *	GEM Application Environment Services		  Version 1.1
 *	Serial No.  XXXX-0000-654321		  All Rights Reserved
 *	Copyright (C) 1985			Digital Research Inc.
 *	-------------------------------------------------------------
 */

#include "aes.h"
#include "gemlib.h"
#include "taddr.h"
#include "gsxdefs.h"


#if BINEXACT
extern int16_t gl_mnpid;
#endif

#define THEDESK 3

#define MBDOWN 0x0001
#define BELL 0x07						/* bell         */

MOBLK gl_ctwait;
int16_t appl_msg[8];
#if 0
int16_t rets[6];							/* added 2/4/87 ... and now unused */
#endif
int16_t ml_ocnt;
int16_t gl_fakemsg;



/* used to convert from window object # to window message code */
STATIC int16_t const gl_wa[] = {
	WA_UPLINE,
	WA_DNLINE,
	WA_UPPAGE,
	WA_DNPAGE,
	0x0,
	WA_LFLINE,
	WA_RTLINE,
	WA_LFPAGE,
	WA_RTPAGE
};


/*
 *	Send message and wait for the mouse button to come up
 */
/* 306de: 00e1b1b4 */
/* 106de: 00e1f38a */
VOID ct_msgup(P(int16_t) message, P(int16_t) owner, P(int16_t) wh, P(int16_t) m1, P(int16_t) m2, P(int16_t) m3, P(int16_t) m4)
PP(int16_t message;)
PP(int16_t owner;)
PP(int16_t wh;)
PP(int16_t m1;)
PP(int16_t m2;)
PP(int16_t m3;)
PP(int16_t m4;)
{
	if (message)
		ap_sendmsg(appl_msg, message, owner, wh, m1, m2, m3, m4);
	/* wait for button to come up */
	while ((button & 0x0001) != 0x0)
		dsptch();
}


/* 104de: 00fddcc4 */
/* 206de: 00e1778e */
/* 306de: 00e1b1f4 */
/* 106de: 00e1f3ca */
VOID hctl_window(P(int16_t) w_handle, P(int16_t) mx, P(int16_t) my)
PP(register int16_t w_handle;)
PP(int16_t mx;)
PP(int16_t my;)
{
	register THEGLO *DGLO;
	GRECT t, f;
	int16_t x, y, w, h;
	int unused2;
	int16_t kind;
	int16_t px, py;
	OBJECT *tree;
	register int wm, hm;
	register int16_t message;
	register int16_t cpt;
	
	UNUSED(unused2);
	
	DGLO = &D;
	message = 0;
	if (w_handle == gl_wtop /* ||
		((D.w_win[w_handle].w_flags & VF_SUBWIN) && (D.w_win[gl_wtop].w_flags & VF_SUBWIN)) */ )
	{
		/* 
		 * went down on active window so handle control points
		 */
		w_bldactive(w_handle);
		tree = gl_awind;
		UNUSED(tree);
		cpt = ob_find((LPTREE) gl_awind, 0, 10, mx, my);
        w_getsize(WS_CURR, w_handle, &t);
        r_get(&t, &x, &y, &w, &h);
		kind = DGLO->w_win[w_handle].w_kind;
		switch (cpt)
		{
		case W_CLOSER:
#if 0
			/*
			 * MagiC feature not supported by TOS;
			 * HOTCLOSE (0x1000) was later used for menubars (MENUBAR) in windows
			 */
			if (kind & HOTCLOSE)
			{
				message = WM_CLOSED;
				break;
			}
#endif
			/* else fall thru */
		case W_FULLER:
			if (gr_watchbox(gl_awind, cpt, SELECTED, NORMAL))
			{
				message = (cpt == W_CLOSER) ? WM_CLOSED : WM_FULLED;
				ob_change((LPTREE) gl_awind, cpt, NORMAL, TRUE);
			}
			break;
		case W_NAME:
			if (DGLO->w_win[w_handle].w_kind & MOVER)
			{
				/* prevent the mover gadget being moved completely offscreen */
				r_set(&f, 0, gl_hbox, gl_rscreen.g_w + w - gl_wbox - 6, 10000);
				gr_dragbox(w, h, x, y, &f, &x, &y);
				message = WM_MOVED;
			}
			break;
		case W_SIZER:
			if (kind & SIZER)
			{
				w_getsize(WS_WORK, w_handle, &t);
				t.g_x -= x;
				t.g_y -= y;
				t.g_w -= w;
				t.g_h -= h;
				wm = gl_wchar;
				hm = gl_hchar;
				if (DGLO->w_win[w_handle].w_kind & (LFARROW | RTARROW | HSLIDE))
					wm = gl_wbox * 7;
				if (DGLO->w_win[w_handle].w_kind & (UPARROW | DNARROW | VSLIDE))
					hm = gl_hbox * 7;
				gr_rubwind(x, y, wm, hm, &t, &w, &h);
				message = WM_SIZED;
			}
			break;
		case W_HSLIDE:
		case W_VSLIDE:
			/*
			 * cpt + 1: W_HSLIDE -> W_HELEV, W_VSLIDE -> W_VELEV
			 */
			ob_offset((LPTREE) gl_awind, cpt + 1, &px, &py);
			if (cpt == W_HSLIDE)
			{
				/* fix up for index into gl_wa */
				if (!(mx < px))
					cpt += 1;
			} else
			{
				if (!(my < py))
					cpt += 1;
			}
			/* fall thru */
		case W_UPARROW:
		case W_DNARROW:
		case W_LFARROW:
		case W_RTARROW:
			message = WM_ARROWED;
			break;
		case W_HELEV:
		case W_VELEV:
			message = cpt == W_HELEV ? WM_HSLID : WM_VSLID;
			/* slide is 1 less than elev */
			x = gr_slidebox((LPTREE) gl_awind, cpt - 1, cpt, cpt == W_VELEV);
			/* break; */
		}
		if (message == WM_ARROWED)
		{
			x = gl_wa[cpt - W_UPARROW];
#if AESVERSION >= 0x140
			wm_update(END_UPDATE);			/* give up the screen */

#if TP_48 /* ARROWFIX */
			{
				register long end = ((((gl_dcindex >> 8) & 0xff) - 1) << 7) / gl_ticktime + TICKS;
				register PD *p;

				p = DGLO->w_win[w_handle].w_owner;
				for (;;)
				{
					if (p->p_qindex <= 0)
					{
						ap_sendmsg(appl_msg, message, p->p_pid, w_handle, x, 0, 0, 0);
					}
					do
					{
						dsptch();
						if (!(button & 1))
							goto done;
					} while (TICKS <= end);
				}
				done:;
			}
#else
			cpt = TRUE;
			do
			{
				if (g_wsend == FALSE)
				{
					ap_sendmsg(appl_msg, message, DGLO->w_win[w_handle].w_owner->p_pid, w_handle, x, y, w, h);
					g_wsend = TRUE;
				}

				dsptch();

				/*
				 * Delay for half current double click time: 
				 * allow button to come back up on single click
				 */
				if (cpt)
				{						/* Only delay 1st time through */
					cpt = FALSE;
					delay((int32_t) gl_dclick);
				}

			} while (button & 1);		/* button is global */
#endif
			wm_update(BEG_UPDATE);			/* take back the screen */
			return;
#else
#endif
		}
	} else
	{
        /*
         * went down on inactive window so tell ap. to bring it to top
         */
		message = WM_TOPPED;
#if 0 & SINGLAPP
		ct_msgup(WM_UNTOPPED, D.w_win[gl_wtop].w_owner->p_pid, gl_wtop, x, y, w, h);
	    for (i = 0; i < NUM_ACCS; i++)
    	    dsptch();
#endif
	}
	/* BUG: x, y, w, h undefined if w_handle != gl_wtop */
	ct_msgup(message, DGLO->w_win[w_handle].w_owner->p_pid, w_handle, x, y, w, h);
}


/* 306de: 00e1b580 */
/* 106de: 00e1f6ea */
VOID hctl_button(P(int16_t) mx, P(int16_t) my)
PP(register int16_t mx;)
PP(register int16_t my;)
{
	register int16_t wh;

	/* find out which wind. the mouse clicked over and handle it */

	if (gl_fakemsg != 0)
	{
		gl_fakemsg--;
	} else
	{
		wh = wm_find(mx, my);
		if (wh > 0)
			hctl_window(wh, mx, my);
	}
}


/* 306de: 00e1b5b6 */
VOID hctl_rect(P(int16_t) mx, P(int16_t) my)
PP(int16_t mx;)
PP(int16_t my;)
{
	int16_t title, item;
	register int16_t owner, mesag;

	if (gl_mntree != 0 && inside(mx, my, &gl_rmnactv))
	{
		mesag = 0;
#ifndef __ALCYON__
		owner = 0;
#endif
		if (mn_do(&title, &item))
		{
			/* check system menu: title == 1st menu && item == deskacc */
			if (gl_dacnt && title == THEDESK && item >= gl_dabase)
			{
				item -= gl_dabase;
				owner = desk_pid[item];
				do_chg(gl_mntree, title, SELECTED, FALSE, TRUE, TRUE);
				mesag = AC_OPEN;
			} else
			{
				owner = gl_mnpid;
				mesag = MN_SELECTED;
			}
		}
		/* application menu item has been selected so send it */
		ct_msgup(mesag, owner, title, item, 0, 0, 0);
	}
}


/*
 *	Control change of ownership to this rectangle and this process
 *	Doing the control rectangle first is important.
 */
/* 306de: 00e1b67a */
/* 106de: 00e1f7f6 */
VOID ct_chgown(P(PD *) ppd, P(GRECT *) pr)
PP(PD *ppd;)
PP(GRECT *pr;)
{
	/* set_ctrl(pr), copy the rect into control */
	set_ctrl(pr);
	/* change the owner */
	set_mown(ppd, ppd);
}


/*
 *	Internal process context used to control the screen for use by
 *	the menu manager, and the window manager.
 *	This process never terminates and forms an integral part of
 *	the system.
 */
/* 306de: 00e1b6de */
/* 106de: 00e1f85a */
VOID ctlmgr(NOTHING)
{
	register int16_t ev_which;
	int16_t lrets[6];

	/* set defaults for multi wait */
	rc_copy(&gl_rmenu, (GRECT *)&gl_ctwait.m_x);
	gl_ctwait.m_out = FALSE;			/* CHANGED LKW      */


	while (1)
	{
		w_setactive();
		/*
		 * if no waiting to go out of menu area
		 * then give mouse to owner of top window
		 */
		/* gsx_mxmy(&mx, &my); */
		/* gl_ctwait.m_out = inside(mx, my, &gl_ctwait.m_x); */

		/* wait for something to happen */
		ev_which = ev_multi(MU_KEYBD | MU_BUTTON | MU_M1, &gl_ctwait, &gl_ctwait, 0x0L, 0x0001ff01L, NULL, lrets);
		/* grab screen sink */
		wm_update(BEG_UPDATE);
		/* button down over area ctrl mgr owns  */
		if (ev_which & MU_BUTTON)
		{
			hctl_button(lrets[0], lrets[1]);
		}
		/* mouse over menu bar */
		if (ev_which & MU_M1)
		{
			hctl_rect(lrets[0], lrets[1]);
		}

		/* give up screen sink */
		wm_update(END_UPDATE);
	}
}


/*
 *	Create a process for the Screen Control Manager and start him 
 *	executing. Also do all the initialization that is required.  
 *	Also zero out the desk accessory count.
 */
/* 306de: 00e1b770 */
/* 106de: 00e1f8ec */
PD *ictlmgr(P(int16_t) pid)
PP(int16_t pid;)
{
	PD *px;
	register int32_t ldaddr;

	UNUSED(px);
	gl_dacnt = 0;
	gl_dabase = 0;
	/* figure out load addr */
	ldaddr = LLCS() + ((int32_t) & ctlmgr);
	/* create process to execute it */
	return pstart(&ctlmgr, "SCRENMGR.LOC", ldaddr);
}
